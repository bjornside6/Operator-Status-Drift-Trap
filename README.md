---

# Operator Status Drift Trap

## Overview

The **Operator Status Drift Trap** is a **Drosera-compatible monitoring contract** designed for the **EigenLayer Hoodi testnet**. It tracks changes in registered operator statuses within the `DelegationManager` and detects **status drifts** that deviate from a predefined set of “healthy” states encoded in the `OperatorConfig`.

This trap can serve as a sentinel for **EigenLayer protocol resilience testing**, automatically triggering a Drosera response when operator status mismatches occur beyond acceptable bounds.

---

## Key Components

### 1. OperatorConfig.sol

This contract stores operator-level configurations, including:

* Allowed “healthy” status bitmask (encoded in `allowedMask`).
* Operator’s address and their assigned configuration.
* Config management functions callable via `cast send`.

The healthy condition is no longer fixed to `status == 1`; it now checks whether `(1 << status)` falls within the configured `allowedMask`, allowing flexible health-state definitions.

```solidity
function isHealthy(uint8 status) external view returns (bool) {
    return (allowedMask & (1 << status)) != 0;
}
```

---

### 2. OperatorStatusDriftTrap.sol

Implements the Drosera `ITrap` interface and operates as a lightweight, view-only monitor for operator health.
It collects operator status data directly from the **DelegationManager** deployed on the **Hoodi testnet**.

* `collect()` samples operator status from the on-chain registry and returns encoded data for Drosera analysis.
* `shouldRespond()` deterministically compares the sampled data to the configured healthy mask and signals Drosera when an anomaly is detected.

**Core Logic:**

```solidity
function collect() external view override returns (bytes memory) {
    uint8 status = IDelegationManager(DELEGATION_MANAGER).getOperatorStatus(OPERATOR);
    return abi.encode(Sample({status: status}));
}

function shouldRespond(bytes[] calldata data)
    external
    view
    override
    returns (bool, bytes memory)
{
    if (data.length == 0) return (false, "");
    Sample memory s = abi.decode(data[0], (Sample));
    bool healthy = IOperatorConfig(CONFIG).isHealthy(s.status);
    if (!healthy) {
        return (true, abi.encode(OPERATOR, bytes32("STATUS_DRIFT")));
    }
    return (false, "");
}
```

---

### 3. OperatorResponder.sol

The responder executes a recovery or mitigation action when Drosera triggers a response.
This can include:

* Emitting on-chain alerts,
* Pausing protocol interactions,
* Or notifying other system contracts depending on operator configuration.

It validates Drosera dispatches and decodes payloads generated by `shouldRespond()`.

---

### 4. drosera.toml

The Drosera configuration file defines trap deployment and monitoring parameters.

```toml
ethereum_rpc = "https://ethereum-hoodi-rpc.publicnode.com"
drosera_rpc = "https://relay.hoodi.drosera.io"
eth_chain_id = 560048
drosera_address = "0x91cB447BaFc6e0EA0F4Fe056F5a9b1F14bb06e5D"

[traps]

[traps.operator_status_drift]
path = "out/OperatorStatusDriftTrap.sol/OperatorStatusDriftTrap.json"
response_contract = "0x48204730bce8de630d68d80e6e3c84844a685d18"
response_function = "respondWithOperatorAlert(address,uint8,uint8,bytes32)"
cooldown_period_blocks = 30
min_number_of_operators = 1
max_number_of_operators = 2
block_sample_size = 2
private_trap = true
whitelist = ["0xcfE6dA9D82BE3bD159e2C1386302FbA0740022E2"]
address = ["0xB7a726806A6524e1a3b06Ee9b5160572aC2CAbB8"]
```

---

## Cast Commands

Use these Foundry `cast` commands to interact and test the trap.

### 1. Set Healthy Mask

```bash
cast send <CONFIG_ADDRESS> \
"setAllowedMask(uint256)" 0x3 \
--private-key $PRIVATE_KEY
```

### 2. Collect Operator Sample

```bash
cast call <TRAP_ADDRESS> "collect()"
```

### 3. Evaluate Trap Decision

```bash
cast call <TRAP_ADDRESS> \
"shouldRespond(bytes[])" \
"[$(cast call <TRAP_ADDRESS> collect)]"
```

### 4. Trigger Response (if applicable)

```bash
cast send <RESPONDER_ADDRESS> \
"respond(bytes)" \
"$(cast call <TRAP_ADDRESS> collect)" \
--private-key $PRIVATE_KEY
```

---

## How It Works

1. **Monitoring**:
   The trap reads operator status directly from the **DelegationManager** on the Hoodi testnet.

2. **Evaluation**:
   The trap encodes each sample and stores it for Drosera’s time-series analysis.

3. **Detection**:
   If an operator’s status no longer matches the allowed mask set in `OperatorConfig`, the trap returns a positive response signal.

4. **Response Execution**:
   The `OperatorResponder` receives the Drosera payload and executes the designated fallback or alert routine.

---

